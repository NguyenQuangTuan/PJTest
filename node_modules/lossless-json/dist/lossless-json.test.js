import { throws, equal, deepEqual, ok } from 'assert';

/**
 * A lossless number. Stores it's value as string
 * @param {string | number} value
 * @constructor
 */
var LosslessNumber = function LosslessNumber (value) {
  // value as string
  this.value = valueToString(value);

  // type information
  this.type = 'LosslessNumber';
  this.isLosslessNumber = true;
};

/**
 * Get the value of the LosslessNumber as number.
 * Will throw an error when this conversion would result in a truncation
 * of the number.
 * @return {Number}
 */
LosslessNumber.prototype.valueOf = function valueOf () {
  var number = parseFloat(this.value);
  var digits = getDigits(this.value);

  // throw an error when the numeric value will lose information
  if (digits.length > 15) {
    throw new Error('Cannot convert to number: ' +
        'number would be truncated (value: ' + this.value + ')');
  }
  if (!isFinite(number)) {
    throw new Error('Cannot convert to number: number would overflow (value: ' + this.value + ')');
  }
  if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {
    throw new Error('Cannot convert to number: number would underflow (value: ' + this.value + ')');
  }

  return number;
};

/**
 * Get the value of the LosslessNumber as string.
 * @return {string}
 */
LosslessNumber.prototype.toString = function toString() {
  return this.value;
};

/**
 * Convert input value to a string
 * If value is no number or string, the valueOf() of the object will be used.
 * @param {number | string} value
 * @return {string}
 */
function valueToString (value) {
  if (typeof value === 'string') {
    if (!isValidNumber(value)) {
      throw new Error('Invalid number (value: "' + value +'")');
    }

    return value;
  }
  else if (typeof value === 'number') {
    // validate number
    if (getDigits(value + '').length > 15) {
      throw new Error('Invalid number: contains more than 15 digits (value: ' + value + ')');
    }
    if (isNaN(value)) {
      throw new Error('Invalid number: NaN');
    }
    if (!isFinite(value)) {
      throw new Error('Invalid number: Infinity');
    }

    return value + '';
  }
  else {
    return valueToString(value && value.valueOf());
  }
}

/**
 * Count the number of significant digits of a number.
 *
 * For example:
 *   '2.34' returns '234'
 *   '-77' returns '77'
 *   '0.0034' returns '34'
 *   '120.5e+30' returns '1205'
 *
 * @param {number | string} value
 * @return {string} Returns the significant digits
 */
function getDigits (value) {
  var _value = (typeof value !== 'string') ? (value + '') : value;

  return _value
      .replace(/^-/, '')            // remove sign
      .replace(/e.*$/, '')          // remove exponential notation
      .replace( /^0\.?0*|\./, '');  // remove decimal point and leading zeros
}

/**
 * Test whether a string contains only zeros or is empty
 * @param {string} text
 * @return {boolean}
 */
function containsOnlyZeros (text) {
  return /^0*$/.test(text);
}

/**
 * Test whether a string contains a valid number
 * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression
 * @param {string} value
 * @return {boolean}
 */
function isValidNumber(value) {
  return /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/.test(value);
}

var circularRefs = true;

/**
 * Get and/or set configuration options
 * @param {{circularRefs: boolean}} [options]
 * @retrun {{circularRefs: boolean}}
 */
function config (options) {
  if (options) {
    if (options.circularRefs != undefined) {
      circularRefs = (options.circularRefs === true);
    }
  }

  return { circularRefs: circularRefs }
}

/**
 * Revive a json object.
 * Applies the reviver function recursively on all values in the JSON object.
 * @param {*} json   A JSON Object, Array, or value
 * @param {function (key: string, value: *)} reviver
 *              A reviver function invoked with arguments `key` and `value`,
 *              which must return a replacement value. The function context
 *              (`this`) is the Object or Array that contains the currently
 *              handled value.
 * @return {*}
 */
function revive (json, reviver) {
  return reviveValue({'': json}, '', json, reviver);
}

/**
 * Revive a value
 * @param {Object | Array} context
 * @param {string} key
 * @param {*} value
 * @param {function(key: string, value: *)} reviver
 * @return {*}
 */
function reviveValue (context, key, value, reviver) {
  if (Array.isArray(value)) {
    return reviver.call(context, key, reviveArray(value, reviver));
  }
  else if (value && typeof value === 'object' && !value.isLosslessNumber) {
    // note the special case for LosslessNumber,
    // we don't want to iterate over the internals of a LosslessNumber
    return reviver.call(context, key, reviveObject(value, reviver))
  }
  else {
    return reviver.call(context, key, value)
  }
}

/**
 * Revive the properties of an object
 * @param {Object} object
 * @param {function} reviver
 * @return {Object}
 */
function reviveObject (object, reviver) {
  var revived = {};

  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      revived[key] = reviveValue(object, key, object[key], reviver);
    }
  }

  return revived;
}

/**
 * Revive the properties of an Array
 * @param {Array} array
 * @param {function} reviver
 * @return {Array}
 */
function reviveArray (array, reviver) {
  var revived = [];

  for (var i = 0; i < array.length; i++) {
    revived[i] = reviveValue(array, i + '', array[i], reviver);
  }

  return revived;
}

// JavaScript Object Notation (JSON) Pointer
// https://tools.ietf.org/html/rfc6901

/**
 * Escape a JSON Pointer
 *
 * @param {string} str
 * @returns {string}
 */
function escape (str) {
  return encodeURIComponent(str
      .replace(/\//g, '~1')
      .replace(/~/g, '~0'));
}

/**
 * Unescape a JSON Pointer
 *
 * @param {string} str
 * @returns {string}
 */
function unescape (str) {
  return decodeURIComponent(str)
      .replace(/~1/g, '/')
      .replace(/~0/g, '~');
}

/**
 * Stringify an array of keys as a JSON Pointer URI fragment
 *
 * Example:
 *
 *     stringify(['foo', 'bar'])     // returns '#/foo/bar'
 *     stringify(['foo bar', 'baz']) // returns '#/foo%20bar/baz'
 *
 * @param {Array.<string>} array
 * @returns {string}
 */
function stringifyPointer(array) {
  return '#/' + array.map(escape).join('/');
}

/**
 * Parse a JSON Pointer URI fragment
 * @param {string} pointer
 * @return {Array.<string>}
 */
function parse$1(pointer) {
  var array = pointer.split('/').map(unescape);

  // remove the hash
  var hash = array.shift();
  if (hash !== '#') {
    throw SyntaxError('Cannot parse JSON Pointer: no valid URI fragment');
  }

  // remove last empty entry
  if (array[array.length - 1] === '') {
    array.pop();
  }

  return array;
}

// token types enumeration
var TOKENTYPE = {
  NULL: 0,
  DELIMITER: 1,
  NUMBER: 2,
  STRING: 3,
  SYMBOL: 4,
  UNKNOWN: 5
};

// map with all delimiters
var DELIMITERS = {
  '': true,
  '{': true,
  '}': true,
  '[': true,
  ']': true,
  ':': true,
  ',': true
};

// map with all escape characters
var ESCAPE_CHARACTERS = {
  '\"': '\"',
  '\\': '\\',
  '/': '/',
  'b': '\b',
  'f': '\f',
  'n': '\n',
  'r': '\r',
  't': '\t'
  // \u is handled by getToken()
};

var jsonText = '';                // current json text
var index = 0;                    // current index in text
var c = '';                       // current token character in text
var token = '';                   // current token
var tokenType = TOKENTYPE.NULL;   // type of current token

// Keep track of the stack to handle circular references
// https://github.com/manuelstofer/json-pointer/blob/master/index.js
// stack of currently stringified objects
var path = [];  // keys on the current stack
var stack = []; // objects (Object or Array) on the current stack

/**
 * The LosslessJSON.parse() method parses a string as JSON, optionally transforming
 * the value produced by parsing.
 *
 * @param {string} text
 * The string to parse as JSON. See the JSON object for a description of JSON syntax.
 *
 * @param {function(key: string, value: *)} [reviver]
 * If a function, prescribes how the value originally produced by parsing is
 * transformed, before being returned.
 *
 * @returns Returns the Object corresponding to the given JSON text.
 *
 * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.
 */
function parse (text, reviver) {
  // initialize
  jsonText = text;
  index = 0;
  c = jsonText.charAt(0);
  token = '';
  tokenType = TOKENTYPE.NULL;

  // clear stack
  stack = [];
  path = [];

  // get first token
  getToken();

  // parse everything
  var json = parseObject();

  if (token != '') {
    throw createSyntaxError('Unexpected characters');
  }

  return reviver ? revive(json, reviver) : json;
}

/**
 * Get the next character from the expression.
 * The character is stored into the char c. If the end of the expression is
 * reached, the function puts an empty string in c.
 * @private
 */
function next() {
  index++;
  c = jsonText.charAt(index);
}

/**
 * Get next token in the current text.
 * The token and token type are available as token and tokenType
 * @private
 */
function getToken() {
  tokenType = TOKENTYPE.NULL;
  token = '';

  // skip over whitespaces: space, tab, newline, and carriage return
  while (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
    next();
  }

  // check for delimiters
  if (DELIMITERS[c]) {
    tokenType = TOKENTYPE.DELIMITER;
    token = c;
    next();
    return;
  }

  // check for a number
  if (isDigit(c) || c == '-') {
    tokenType = TOKENTYPE.NUMBER;

    if (c == '-') {
      token += c;
      next();

      if (!isDigit(c)) {
        throw createSyntaxError('Invalid number, digit expected', index);
      }
    }
    else if (c == '0') {
      token += c;
      next();
    }
    else {
      // digit 1-9, nothing extra to do
    }

    while (isDigit(c)) {
      token += c;
      next();
    }

    if (c == '.') {
      token += c;
      next();

      if (!isDigit(c)) {
        throw createSyntaxError('Invalid number, digit expected', index);
      }

      while (isDigit(c)) {
        token += c;
        next();
      }
    }

    if (c == 'e' || c == 'E') {
      token += c;
      next();

      if (c == '+' || c == '-') {
        token += c;
        next();
      }

      if (!isDigit(c)) {
        throw createSyntaxError('Invalid number, digit expected', index);
      }

      while (isDigit(c)) {
        token += c;
        next();
      }
    }

    return;
  }

  // check for a string
  if (c == '"') {
    tokenType = TOKENTYPE.STRING;
    next();

    while (c != '' && c != '"') {

      if (c == '\\') {
        // handle escape characters
        next();

        var unescaped = ESCAPE_CHARACTERS[c];
        if (unescaped !== undefined) {
          token += unescaped;
          next();
        }
        else if (c == 'u') {
          // parse escaped unicode character, like '\\u260E'
          next();

          var hex = '';
          for (var u = 0; u < 4; u++) {
            if (!isHex(c)) {
              throw createSyntaxError('Invalid unicode character');
            }
            hex += c;
            next();
          }

          token += String.fromCharCode(parseInt(hex, 16));
        }
        else {
          throw createSyntaxError('Invalid escape character "\\' + c + '"', index);
        }
      }
      else {
        // a regular character
        token += c;
        next();
      }
    }

    if (c != '"') {
      throw createSyntaxError('End of string expected');
    }
    next();

    return;
  }

  // check for symbols (true, false, null)
  if (isAlpha(c)) {
    tokenType = TOKENTYPE.SYMBOL;

    while (isAlpha(c)) {
      token += c;
      next();
    }

    return;
  }

  // something unknown is found, wrong characters -> a syntax error
  tokenType = TOKENTYPE.UNKNOWN;
  while (c != '') {
    token += c;
    next();
  }
  throw createSyntaxError('Syntax error in part "' + token + '"');
}

/**
 * Check if the given character contains an alpha character, a-z, A-Z, _
 * @param {string} c   a string with one character
 * @return {boolean}
 */
function isAlpha (c) {
  return /^[a-zA-Z_]/.test(c);
}

/**
 * Check if the given character contains a hexadecimal character 0-9, a-f, A-F
 * @param {string} c   a string with one character
 * @return {boolean}
 */
function isHex (c) {
  return /^[0-9a-fA-F]/.test(c);
}

/**
 * checks if the given char c is a digit
 * @param {string} c   a string with one character
 * @return {boolean}
 * @private
 */
function isDigit (c) {
  return (c >= '0' && c <= '9');
}

/**
 * Create an error
 * @param {string} message
 * @param {number} [c]  Optional index (character position) where the
 *                      error happened. If not provided, the start of
 *                      the current token is taken
 * @return {SyntaxError} instantiated error
 * @private
 */
function createSyntaxError (message, c) {
  if (c === undefined) {
    c = index - token.length;
  }
  var error = new SyntaxError(message + ' (char ' + c + ')');
  error['char'] = c;

  return error;
}

/**
 * Parse an object like '{"key": "value"}'
 * @return {*}
 */
function parseObject () {
  if (token == '{') {
    getToken();

    var key;
    var object = {};

    if (token == '}') {
      // empty object
      getToken();
      return object;
    }

    // add this object to the stack
    var stackIndex = stack.length;
    stack[stackIndex] = object;

    while (true) {
      // parse key
      if (tokenType != TOKENTYPE.STRING) {
        throw createSyntaxError('Object key expected');
      }
      key = token;
      getToken();

      // parse key/value separator
      if (token != ':') {
        throw createSyntaxError('Colon expected');
      }
      getToken();

      // parse value
      path[stackIndex] = key;
      object[key] = parseObject();

      // parse key/value pair separator
      if (token != ',') {
        break;
      }
      getToken();
    }

    if (token != '}') {
      throw createSyntaxError('Comma or end of object "}" expected');
    }
    getToken();

    // check whether this is a circular reference
    if (isCircular(object)) {
      return parseCircular(object);
    }

    // remove current entry from the stack
    stack.length = stackIndex;
    path.length = stackIndex;

    return object;
  }

  return parseArray();
}

/**
 * Parse an object like '["item1", "item2", ...]'
 * @return {*}
 */
function parseArray () {
  if (token == '[') {
    getToken();

    var array = [];

    if (token == ']') {
      // empty array
      getToken();
      return array;
    }

    // add this array to the stack
    var stackIndex = stack.length;
    stack[stackIndex] = array;

    while (true) {
      // parse item
      path[stackIndex] = array.length + '';
      array.push(parseObject());

      // parse item separator
      if (token != ',') {
        break;
      }
      getToken();
    }

    if (token != ']') {
      throw createSyntaxError('Comma or end of array "]" expected');
    }
    getToken();

    // remove current entry from the stack
    stack.length = stackIndex;
    path.length = stackIndex;

    return array;
  }

  return parseString();
}

/**
 * Parse a string enclosed by double quotes "...". Can contain escaped quotes
 * @return {*}
 */
function parseString () {
  if (tokenType == TOKENTYPE.STRING) {
    var str = token;
    getToken();
    return str;
  }

  return parseNumber();
}

/**
 * Parse a number. The number will be parsed as a LosslessNumber.
 * @return {*}
 */
function parseNumber () {
  if (tokenType == TOKENTYPE.NUMBER) {
    var number = new LosslessNumber(token);
    getToken();
    return number;
  }

  return parseSymbol();
}

/**
 * Parse constants true, false, null
 * @return {boolean | null}
 */
function parseSymbol () {
  if (tokenType == TOKENTYPE.SYMBOL) {
    if (token === 'true') {
      getToken();
      return true;
    }
    if (token === 'false') {
      getToken();
      return false;
    }
    if (token === 'null') {
      getToken();
      return null;
    }

    throw createSyntaxError('Unknown symbol "' + token + '"');
  }

  return parseEnd();
}

/**
 * Evaluated when the expression is not yet ended but expected to end
 */
function parseEnd () {
  if (token == '') {
    // syntax error or unexpected end of expression
    throw createSyntaxError('Unexpected end of json string');
  } else {
    throw createSyntaxError('Value expected');
  }
}

/**
 * Test whether an object is a circular reference, like {$ref: '#/foo/bar'}
 * @param {Object} object
 * @return {boolean}
 */
function isCircular (object) {
  return typeof object.$ref === 'string' && Object.keys(object).length === 1;
}

/**
 * Resolve a circular reference.
 * Throws an error if the path cannot be resolved
 * @param {Object} object    An object with a JSON Pointer URI fragment
 *                           like {$ref: '#/foo/bar'}
 * @return {Object | Array}
 */
function parseCircular(object) {
  // if circular references are disabled, just return the refs object
  if (!config().circularRefs) {
    return object;
  }

  var pointerPath = parse$1(object.$ref);

  // validate whether the path corresponds with current stack
  for (var i = 0; i < pointerPath.length; i++) {
    if (pointerPath[i] !== path[i]) {
      throw new Error('Invalid circular reference "' +  object.$ref + '"');
    }
  }

  return stack[pointerPath.length];
}

// map with control characters to be escaped
var CONTROL_CHARACTERS = {
  '"': '\\"',
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t'
};

// Keep track of the stack to handle circular references
// https://github.com/manuelstofer/json-pointer/blob/master/index.js
// stack of currently stringified objects
var path$1 = [];  // keys on the current stack
var stack$1 = []; // objects (Object or Array) on the current stack

/**
 * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,
 * optionally replacing values if a replacer function is specified, or
 * optionally including only the specified properties if a replacer array is specified.
 *
 * @param {*} value
 * The value to convert to a JSON string.
 *
 * @param {function(key: string, value: *) | Array.<string | number>} [replacer]
 * A function that alters the behavior of the stringification process,
 * or an array of String and Number objects that serve as a whitelist for
 * selecting the properties of the value object to be included in the JSON string.
 * If this value is null or not provided, all properties of the object are
 * included in the resulting JSON string.
 *
 * @param {number | string} [space]
 * A String or Number object that's used to insert white space into the output
 * JSON string for readability purposes. If this is a Number, it indicates the
 * number of space characters to use as white space; this number is capped at 10
 * if it's larger than that. Values less than 1 indicate that no space should be
 * used. If this is a String, the string (or the first 10 characters of the string,
 * if it's longer than that) is used as white space. If this parameter is not
 * provided (or is null), no white space is used.
 *
 * @returns {string | undefined} Returns the string representation of the JSON object.
 */
function stringify(value, replacer, space) {
  // clear stack
  stack$1 = [];
  path$1 = [];

  var _value = (typeof replacer === 'function')
      ? replacer.call({'': value}, '', value)
      : value;

  var _space; // undefined by default
  if (typeof space === 'number') {
    if (space > 10) {
      _space = repeat(' ', 10);
    }
    else if (space >= 1) {
      _space = repeat(' ', space);
    }
    // else ignore
  }
  else if (typeof space === 'string' && space !== '') {
    _space = space;
  }

  return stringifyValue(_value, replacer, _space, '');
}

/**
 * Stringify a value
 * @param {*} value
 * @param {function | Array.<string | number>} [replacer]
 * @param {string} [space]
 * @param {string} [indent]
 * @return {string | undefined}
 */
function stringifyValue(value, replacer, space, indent) {
  // boolean
  if (value === true || value === false || value instanceof Boolean) {
    return value + '';
  }

  // null
  if (value === null) {
    return 'null';
  }

  // number
  if (typeof value === 'number' || value instanceof Number) {
    if (isNaN(value) || !isFinite(value)) {
      return 'null';
    }
    return value + '';
  }

  // lossless number, the secret ingredient :)
  if (value && value.isLosslessNumber) {
    return value.value;
  }

  // string
  if (typeof value === 'string' || value instanceof String) {
    var escaped = '';

    for (var i = 0; i < value.length; i++) {
      var c = value[i];
      escaped += CONTROL_CHARACTERS[c] || c;
    }

    return '"' + escaped + '"';
  }

  // date
  if (value instanceof Date) {
    return '"' + value.toISOString() + '"';
  }

  // array
  if (Array.isArray(value)) {
    return stringifyArray(value, replacer, space, indent);
  }

  // object (test lastly!)
  if (value && typeof value === 'object') {
    return stringifyObject(value, replacer, space, indent);
  }

  return undefined;
}

/**
 * Stringify an array
 * @param {Array} array
 * @param {function | Array.<string | number>} [replacer]
 * @param {string} [space]
 * @param {string} [indent]
 * @return {string}
 */
function stringifyArray(array, replacer, space, indent) {
  var childIndent = space ? (indent + space) : undefined;
  var str = space ? '[\n' : '[';

  // check for circular reference
  if (isCircular$1(array)) {
    return stringifyCircular(array, replacer, space, indent);
  }

  // add this array to the stack
  var stackIndex = stack$1.length;
  stack$1[stackIndex] = array;

  for (var i = 0; i < array.length; i++) {
    var key = i + '';
    var item = (typeof replacer === 'function')
        ? replacer.call(array, key, array[i])
        : array[i];

    if (space) {
      str += childIndent;
    }

    if (typeof item !== 'undefined' && typeof item !== 'function') {
      path$1[stackIndex] = key;
      str += stringifyValue(item, replacer, space, childIndent);
    }
    else {
      str += 'null'
    }

    if (i < array.length - 1) {
      str += space ? ',\n' : ',';
    }
  }

  // remove current entry from the stack
  stack$1.length = stackIndex;
  path$1.length = stackIndex;

  str += space ? ('\n' + indent + ']') : ']';
  return str;
}

/**
 * Stringify an object
 * @param {Object} object
 * @param {function | Array.<string | number>} [replacer]
 * @param {string} [space]
 * @param {string} [indent]
 * @return {string}
 */
function stringifyObject(object, replacer, space, indent) {
  var childIndent = space ? (indent + space) : undefined;
  var first = true;
  var str = space ? '{\n' : '{';

  if (typeof object.toJSON === 'function') {
    return stringify(object.toJSON(), replacer, space);
  }

  // check for circular reference
  if (isCircular$1(object)) {
    return stringifyCircular(object, replacer, space, indent);
  }

  // add this object to the stack
  var stackIndex = stack$1.length;
  stack$1[stackIndex] = object;

  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      var value = (typeof replacer === 'function')
          ? replacer.call(object, key, object[key])
          : object[key];

      if (includeProperty(key, value, replacer)) {
        if (first) {
          first = false;
        }
        else {
          str += space ? ',\n' : ',';
        }

        str += space
          ? (childIndent + '"' + key + '": ')
          : ('"' + key + '":');

        path$1[stackIndex] = key;
        str += stringifyValue(value, replacer, space, childIndent);
      }
    }
  }

  // remove current entry from the stack
  stack$1.length = stackIndex;
  path$1.length = stackIndex;

  str += space ? ('\n' + indent + '}') : '}';
  return str;
}

/**
 * Test whether an object or array is a circular reference
 * @param {Object | Array} value
 * @return {boolean}
 */
function isCircular$1(value) {
  return stack$1.indexOf(value) !== -1;
}

/**
 * Stringify a circular reference
 * @param {Object | Array} value
 * @param {function | Array.<string | number>} [replacer]
 * @param {string} [space]
 * @param {string} [indent]
 * @return {string}
 */
function stringifyCircular (value, replacer, space, indent) {
  if (!config().circularRefs) {
    throw new Error('Circular reference at "' + stringifyPointer(path$1) + '"');
  }

  var pathIndex = stack$1.indexOf(value);

  var circular = {
    $ref: stringifyPointer(path$1.slice(0, pathIndex))
  };

  return stringifyObject(circular, replacer, space, indent);
}

/**
 * Test whether to include a property in a stringified object or not.
 * @param {string} key
 * @param {*} value
 * @param {function(key: string, value: *) | Array<string | number>} [replacer]
 * @return {boolean}
 */
function includeProperty (key, value, replacer) {
  return typeof value !== 'undefined'
      && typeof value !== 'function'
      && (!Array.isArray(replacer) || contains(replacer, key));
}

/**
 * Check whether an array contains some value.
 * Uses a non-strict comparison, so contains([1,2,3], '2') returns true
 * @param {Array} array
 * @param {*} value
 * @return {boolean}
 */
function contains(array, value) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] == value) { // non-strict equality check!
      return true;
    }
  }
  return false;
}

/**
 * Repeat a string a number of times.
 * Simple linear solution, we only need up to 10 iterations in practice
 * @param {string} text
 * @param {number} times
 * @return {string}
 */
function repeat (text, times) {
  var res = '';
  while (times-- > 0) {
    res += text;
  }
  return res;
}

// helper function to create a lossless number
function lln (value) {
  return new LosslessNumber(value);
}

describe ('parse', function () {

  it('should parse a full JSON object', function () {
    var text = '{"a":2.3e500,"b":"str","c":null,"d":false,"e":[1,2,3]}';
    var expected = {a: lln('2.3e500'), b:'str', c: null, d: false, e:[lln(1), lln(2), lln(3)]};
    var parsed = parse(text);

    deepEqual(parsed, expected, 'should parse a JSON object correctly');
  });

  it('should parse an object', function () {
    deepEqual(parse('{}'), {}, 'should parse an empty object');
    deepEqual(parse('  { \n } \t '), {}, 'should parse an empty object with whitespaces');
    deepEqual(parse('{"a": {}}'), {a: {}}, 'should parse an object containing an object');
    deepEqual(parse('{"a": "b"}'), {a: 'b'}, 'should parse a non-empty object');
    deepEqual(parse('{"a": 2}'), {a: lln(2)}, 'should parse a non-empty object');
  });

  it('should parse an array', function () {
    deepEqual(parse('[]'), [], 'should parse an empty array');
    deepEqual(parse('[{}]'), [{}], 'should parse an array containing an object');
    deepEqual(parse('{"a":[]}'), {a:[]}, 'should parse an object containing an array');
    deepEqual(parse('[1, "hi", true, false, null, {}, []]'), [lln(1), "hi", true, false, null, {}, []], 'should parse a non-empty array');
  });

  it('should parse a number', function () {
    ok(parse('2.3e500').isLosslessNumber, 'should parse a large number into a LosslessNumber');
    ok(parse('123456789012345678901234567890').isLosslessNumber, 'should parse a large number into a LosslessNumber');
    deepEqual(parse('23'), lln('23'), 'should parse a number');
    deepEqual(parse('0'), lln('0'), 'should parse a number');
    deepEqual(parse('0e+2'), lln('0e+2'), 'should parse a number');
    deepEqual(parse('0e+2').valueOf(), 0, 'should parse a number');
    deepEqual(parse('0.0'), lln('0.0'), 'should parse a number');
    deepEqual(parse('-0'), lln('-0'), 'should parse a number');
    deepEqual(parse('2.3'), lln(2.3), 'should parse a number');
    deepEqual(parse('2300e3'), lln('2300e3'), 'should parse a number');
    deepEqual(parse('2300e+3'), lln('2300e+3'), 'should parse a number');
    deepEqual(parse('-2'), lln('-2'), 'should parse a negative number');
    deepEqual(parse('2e-3'), lln('2e-3'), 'should parse a number');
    deepEqual(parse('2.3e-3'), lln('2.3e-3'), 'should parse a number');
  });

  it('should parse a LosslessNumber', function () {
    var str = '22222222222222222222';
    deepEqual(parse(str), lln(str), 'should parse a LosslessNumber without information loss');

    var str2 = '2.3e+500';
    deepEqual(parse(str2), lln(str2), 'should parse a LosslessNumber without information loss');

    var str3 = '2.3e-500';
    deepEqual(parse(str3), lln(str3), 'should parse a LosslessNumber without information loss');
  });

  it('should parse a string', function () {
    deepEqual(parse('"str"'), 'str', 'should parse a string');
    deepEqual(parse('"\\"\\\\\\/\\b\\f\\n\\r\\t"'), '"\\/\b\f\n\r\t', 'should parse a string with escape characters');
    deepEqual(JSON.parse('"\\"\\\\\\/\\b\\f\\n\\r\\t"'), '"\\/\b\f\n\r\t', 'should parse a string with escape characters');
    deepEqual(parse('"\\u260E"'), '\u260E', 'should parse a string with unicode');
    deepEqual(JSON.parse('"\\u260E"'), '\u260E', 'should parse a string with unicode');
  });

  it('should parse keywords', function () {
    equal(parse('true'), true, 'should parse true');
    equal(parse('false'), false, 'should parse false');
    equal(parse('null'), null, 'should parse null');
  });

  describe ('reviver', function () {
    it('should replace values using a reviver', function () {
      var text = '{"a":123,"b":"str"}';

      var expected = {
        type: 'object',
        value: {
          a: {type: 'object', value: lln(123)},
          b: {type: 'string', value: 'str'}
        }
      };

      function reviver (key, value) {
        return {
          type: typeof value,
          value: value
        };
      }

      deepEqual(parse(text, reviver), expected);
    });

    it('should invoke callbacks with key/value and correct context using a reviver', function () {
      var text = '{"a":123,"b":"str","c":null,"d":false,"e":[1,2,3]}';

      var expected = [
        {
          context: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] },
          key: 'a',
          value: 123
        },
        {
          context: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] },
          key: 'b',
          value: 'str'
        },
        {
          context: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] },
          key: 'c',
          value: null
        },
        {
          context: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] },
          key: 'd',
          value: false
        },
        {
          context: [1, 2, 3],
          key: '0',
          value: 1
        },
        {
          context: [1, 2, 3],
          key: '1',
          value: 2
        },
        {
          context: [1, 2, 3],
          key: '2',
          value: 3
        },
        {
          context: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] },
          key: 'e',
          value: [1,2,3]
        },
        {
          context: {'': { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] }},
          key: '',
          value: { a: 123, b: 'str', c: null, d: false, e: [1, 2, 3] }
        }
      ];

      // convert LosslessNumbers to numbers for easy comparison with native JSON
      function toRegularJSON(json) {
        return JSON.parse(stringify(json))
      }

      var logs = [];
      parse(text, function (key, value) {
        logs.push({
          context: toRegularJSON(this),
          key: key,
          value: toRegularJSON(value)
        });
        return value;
      });
      deepEqual(logs, expected);

      // validate expected outcome against native JSON.parse
      var logs2 = [];
      JSON.parse(text, function (key, value) {
        logs2.push({context: JSON.parse(JSON.stringify(this)), key: key, value: value});
        return value;
      });
      deepEqual(logs2, expected);
    });

    it('should revive a lossless number correctly', function () {
      var text = '2.3e+500';
      var expected = [
        {key: '', value: lln('2.3e+500')}
      ];
      var logs = [];

      parse(text, function (key, value) {
        logs.push({key: key, value: value});
        return value;
      });
      deepEqual(logs, expected);
    });

  });

  describe ('circular references', function () {

    it('should parse circular reference (1)', function () {
      var text = '{"a":{"b":{"$ref":"#/"}}}';
      var json = parse(text);

      equal(json.a.b, json);
    });

    it('should parse circular reference (2)', function () {
      var text = '{"a":{"b":{"b":{"$ref":"#/a/b"}}}}';
      var json  = parse(text);

      equal(json.a.b.b, json.a.b);
    });

    it('should parse circular reference (3)', function () {
      var text = '{"a":[{},{"b":{"a":{"$ref":"#/a"}}}]}';
      var json = parse(text);

      equal(json.a[1].b.a, json.a);
    });
  });


  it('should throw exceptions', function () {
    throws(function () {parse('')}, /Unexpected end of json string/, 'should throw an exception when parsing an invalid number');

    throws(function () {parse('{')}, /Object key expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('{"a",')}, /Colon expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('{a:2}')}, /Object key expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('{"a":2,}')}, /Object key expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('{"a" "b"}')}, /Colon expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('{}{}')}, /Unexpected characters/, 'should throw an exception when parsing an invalid number');

    throws(function () {parse('[')}, /Unexpected end of json string/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('[2,')}, /Unexpected end of json string/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('[2,]')}, /Value expected/, 'should throw an exception when parsing an invalid number');

    throws(function () {parse('2.3.4')}, /Syntax error in part ".4" \(char 3\)/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('2..3')}, /Invalid number, digit expected \(char 2\)/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('2e3.4')}, /Syntax error in part ".4" \(char 3\)/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('2e')}, /Invalid number, digit expected \(char 2\)/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('-')}, /Invalid number, digit expected \(char 1\)/, 'should throw an exception when parsing an invalid number');

    throws(function () {parse('"a')}, /End of string expected/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('foo')}, /Unknown symbol "foo"/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('"\\a"')}, /Invalid escape character "\\a" /, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('"\\u26"')}, /Invalid unicode character/, 'should throw an exception when parsing an invalid number');
    throws(function () {parse('"\\uZ000"')}, /Invalid unicode character/, 'should throw an exception when parsing an invalid number');
  });

});